

%decls %{
    #include <string>
    #include <unordered_map>
    #include <iostream>
    #include <iomanip>
    #include <vector>
    #include <variant>

    using valores = std::variant<std::string, int>;
    using stdstring = std::string;

    struct variable_valor{
        stdstring Identificador;
        stdstring direccion;
        valores valor;
    };

    struct variable_Tipo{
        stdstring Tipo;
        stdstring variable;
    };

    using Variables = std::vector<variable_valor>;
    using Tipos = std::vector<variable_Tipo>;

    void resetCodegen();
	int getOffset();
	int addOffset();
	stdstring newLabel();
    bool siTipo(Tipos& tipo_var, std::string var, std::string tipo);
    stdstring TipoVar(std::string var);
%}

%{
    #include <iostream>
    #include <string>
    #include <variant>
    #include <iomanip>
    #include <vector>
    #include <algorithm>
    #include "CompiAst.hpp"
    int labels = 0;
    int offset = 4;
    int offset_stmts = 0;
    int drec = 0;
    Variables vars;

    
    void resetCodegen(){
		offset = 0;
		labels = 0;
		drec = 0;
	}

	int getOffset(){
		
		return offset;
	}

	int addOffset()
	{
		return offset += 4;
	}
    int getOffset_stmt(){
		
		return offset_stmts;
	}

	int addOffset_stmt()
	{
		return offset_stmts += 4;
	}

	stdstring newLabel()
	{
		std::string temp = "label_" + std::to_string(labels);
		labels += 1;
		return temp;
	}

	stdstring newTemp()
	{	
		std::string temp = "T" + std::to_string(drec);
		drec += 1;
		return temp;
	}

    stdstring getPlace(AstNode* e){
		if(e->isA(NumExpr_kind))
			return e->place;
        else if(e->isA(CaracterExpr_kind))
            return e->place;
        else if(e->isA(BoolExpr_kind))
            return e->place;
		return "dword ["+e->place+"]";
	}


    bool siTipo(Tipos& tipo_var, std::string var, std::string tipo)
    {
        for (int i =0 ; i < tipo_var.size(); i++)
        {
            if(tipo_var[i].variable == var)
            {
                if(tipo_var[i].Tipo == tipo)
                {
                    return true;
                }
            }
        }
        return false;
    }


    stdstring TipoVar(Tipos& tipo_var, std::string var)
    {
        for (int i =0 ; i < tipo_var.size(); i++)
        {
            if(tipo_var[i].variable == var)
            {
                return tipo_var[i].Tipo;
            }
        }

        return "";
    }
%}

%option lang = "C++"

%node AstNode %abstract %typedef = {
    %nocreate stdstring place;
    %nocreate stdstring code;
}

%node Expr AstNode %abstract


%node Program AstNode = {
    AstNode *declVar;
    AstNode *declFun;
    AstNode *main;
}

%node BinaryExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node AddExpr BinaryExpr
%node MulExpr BinaryExpr
%node DivExpr BinaryExpr
%node SubExpr BinaryExpr
%node ModExpr BinaryExpr

%node MayorExpr BinaryExpr
%node MenorExpr BinaryExpr
%node MayorIExpr BinaryExpr
%node MenorIExpr BinaryExpr
%node IgualExpr BinaryExpr
%node DesigualExpr BinaryExpr

%node OrExpr BinaryExpr
%node AndExpr BinaryExpr



%node NumExpr Expr = {
    int value;
}

%node IdentExpr Expr = {
    stdstring text;
}

%node BoolExpr Expr = {
    int booleano;
}

%node CaracterExpr Expr = {
    char character;
}
%node CadenaExpr Expr = {
    stdstring cadena;
}

%node ArregloExpr Expr = {
    stdstring txt;
}

%node Stmt AstNode %abstract 

%node Vacio Stmt = {

}

%node BlockStmts Stmt = {
    AstNode * stmt1;
    AstNode * stmt2; 
}
//nodo para declaraciones de variables

%node DeclaracionStmt Expr = {
    AstNode* ident1;
    AstNode* ident2;
}

%node Declaracionvariable Stmt = {
    AstNode * ident;
    AstNode * ident2;
}


%node AsignarStmt Stmt = {
    IdentExpr *var;
    AstNode *var_value;
}

%node ForStmt Stmt = {
    AsignarStmt * asignacion;
    Expr * hasta;
    AstNode * stmtst;
}

%node EscribaStmt Stmt = {
    AstNode *expr1;
}

%node IfStmt Stmt = {
    AstNode *condi;
    AstNode *stmt_tr;
    AstNode *stmt_f;
}

%node WhileStmt Stmt = {
    AstNode *condi;
    AstNode *stmt_tr;
}

%node RetorneStmt Stmt = {
    AstNode *retorno;
}

%node LeaStmt Stmt = {
    AstNode *leer;
}



//%operation stdstring toString(AstNode *expr) = {""}
%operation %virtual int semantica(AstNode *this)
%operation %virtual stdstring Gencode(AstNode *this,Tipos& tipos)

semantica(AddExpr) {

    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 + v2;
}

semantica(MulExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 * v2;
}

semantica(SubExpr) {
    double v1 = expr1->semantica();
    double v2 = expr2->semantica( );

    return v1 - v2;
}

semantica(DivExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 / v2;
}

semantica(MayorExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 > v2;
}

semantica(MenorExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 < v2;
}

semantica(MayorIExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 >= v2;
}

semantica(MenorIExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 <= v2;
}

semantica(IgualExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 == v2;
}

semantica(DesigualExpr) {
    double v1 = expr1->semantica( );
    double v2 = expr2->semantica( );

    return v1 != v2;
}

semantica(ModExpr) {
    
    return 0;
}



semantica(OrExpr) {
    
    return 0;
}

semantica(AndExpr) {
    
    return 0;
}

semantica(NumExpr) {
    
    return value;
}

semantica(IdentExpr) {
    

    return 0.0;
}

semantica(AsignarStmt) {
    var->semantica();
    var_value->semantica();
    return 0.0;
}

semantica(EscribaStmt) {
    std::ostringstream stream;
    stream << std::fixed << std::setprecision(2) << expr1->semantica();
    std::string cadena = stream.str();
    
    return 0.0;
}

semantica(IfStmt) {

   // std::cout<< toString(condi) << " = " <<condi->semantica() << "\n" ;
    if(condi->semantica() != 0.0)
    {
        stmt_tr->semantica();
    }else
    {
        stmt_f->semantica();
    }
    
    return 0.0;
}

semantica(CaracterExpr) {

   // std::cout<< toString(condi) << " = " <<condi->semantica() << "\n" ;
    
    return 0.0;
}

semantica(CadenaExpr) {

   // std::cout<< toString(condi) << " = " <<condi->semantica() << "\n" ;
    
    return 0.0;
}

semantica(BlockStmts) {
    stmt1->semantica();
    stmt2->semantica();
    return 0.0;
}

semantica(DeclaracionStmt) {
    return 0.0;
}

semantica(Program) {
    declVar->semantica();
    declFun->semantica();
    main->semantica();

    return 0.0;
}


semantica(Declaracionvariable) {
    //stmts->semantica();

    return 0.0;
}

semantica(ForStmt) {
    return 0.0;
}


semantica(BoolExpr) {
    return 0.0;
}



semantica(RetorneStmt) {
    return 0.0;
}

semantica(WhileStmt) {
    return 0.0;
}
semantica(ArregloExpr) {
    return 0.0;
}

semantica(LeaStmt) {
    return 0.0;
}

semantica(Vacio) {
    return 0.0;
}
////////////////////////////////////

Gencode(AddExpr) {
    place = "ebp - " + std::to_string(addOffset_stmt());

    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    code += "\tmov eax, " + getPlace(expr1) + "\n";
    code += "\tadd eax, " + getPlace(expr2) + "\n";
    code += "\tmov [" + place + "], eax\n";
    return code;
}

Gencode(MulExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
	code += "\tmov eax, " + getPlace(expr1) +"\n\timul eax, " + getPlace(expr2) + "\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(SubExpr) {
    place = "ebp - " + std::to_string(addOffset_stmt());

    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    code += "\tmov eax, " + getPlace(expr1) + "\n";
    code += "\tsub eax, " + getPlace(expr2) + "\n";
    code += "\tmov [" + place + "], eax\n";
    return code;
}

Gencode(DivExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcdq\n\tmov ebx, "+ getPlace(expr2) +"\n\tidiv ebx\n";

	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(MayorExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
    std::string label = newLabel();
	std::string final = newLabel();
	code += "\tjle "+ label +"\n";
	code += "\tmov eax, 1\n\tjmp "+final+"\n"+label+": \n\t mov eax, 0\n"+final+":\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(MenorExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
	std::string label = newLabel();
	std::string final = newLabel();
	code += "\tjge "+ label +"\n";
	code += "\tmov eax, 1\n\tjmp "+final+"\n"+label+": \n\t mov eax, 0\n"+final+":\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(MayorIExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
	std::string label = newLabel();
	std::string final = newLabel();
	code += "\tjl "+ label +"\n";
	code += "\tmov eax, 1\n\tjmp "+final+"\n"+label+": \n\t mov eax, 0\n"+final+":\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(MenorIExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
	std::string label = newLabel();
	std::string final = newLabel();
	code += "\tjg "+ label +"\n";
	code += "\tmov eax, 1\n\tjmp "+final+"\n"+label+": \n\t mov eax, 0\n"+final+":\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(IgualExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
	std::string label = newLabel();
	std::string final = newLabel();
	code += "\tjne "+ label +"\n";
	code += "\tmov eax, 1\n\tjmp "+final+"\n"+label+": \n\t mov eax, 0\n"+final+":\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(DesigualExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
	std::string label = newLabel();
	std::string final = newLabel();
	code += "\tje "+ label +"\n";
	code += "\tmov eax, 1\n\tjmp "+final+"\n"+label+": \n\t mov eax, 0\n"+final+":\n";
	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(ModExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr1) +"\n\tcdq\n\tmov ebx, "+ getPlace(expr2) +"\n\tidiv ebx\n";

	code += "\tmov ["+ place + "], edx\n";
	code += "\tmov eax, edx\n";
	return code;
}

Gencode(OrExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
    
    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

    code += "\tmov eax, " + getPlace(expr1) +"\n\tor eax, " + getPlace(expr2) + "\n";
    code += "\tmov ["+ place + "], eax\n";
    return code;
}

Gencode(AndExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
    
    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

    code += "\tmov eax, " + getPlace(expr1) +"\n\tand eax, " + getPlace(expr2) + "\n";
    code += "\tmov ["+ place + "], eax\n";
    return code;
}

Gencode(NumExpr) {
    place = std::to_string(value);
    code = "";
    return "";
}

Gencode(BoolExpr) {
    place = std::to_string(booleano);
    code = "";
    return "";
}

Gencode(IdentExpr) {
    bool encontrado = false;
    for (const auto& var : vars) {
        if (var.Identificador == text) {
            encontrado = true;
            place = var.direccion;
            break;
        }
    }

    if (!encontrado) {
        place = "ebp + " +std::to_string(addOffset());
        vars.push_back({text, place, 0});
        //code = "\tpush 0\n";
    }
    return "";
}

Gencode(CaracterExpr) {

    int valor_ascii = static_cast<int>(character);
    place = std::to_string(valor_ascii);
    code = "";
    return "";
}

Gencode(CadenaExpr) {
    
    
    //place = std::to_string(valor_ascii);
    code = "";
    return "";
}

Gencode(ArregloExpr) {
    

   
    return "";
}


Gencode(AsignarStmt) {

    bool encontrado = false;
    for (const auto& vari : vars) {
        if (vari.Identificador == var->text) {
            encontrado = true;
            
            var->Gencode(tipos);

            break;
        }
    }

    if (!encontrado) {
        
        std::string msgcompleto = "Error:variable no declarada " + var->text;
        throw std::runtime_error(msgcompleto.c_str());\
    }
    

    

    //hacer validacion que el valor sea del tipo de numero
    if(var_value->isA(NumExpr_kind))
    {
        
        if(siTipo(tipos, var->text, "Entero"))
        {
            var_value->Gencode(tipos);
        }else
        {
            std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo Entero" ;
            throw std::runtime_error(msgcompleto.c_str());\
        }

    }else if (var_value->isA(IdentExpr_kind))
    {

        for (const auto& vari : vars) {
            if (vari.Identificador == var->text) {
                encontrado = true;
                std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(var_value)->text);
                
                if(siTipo(tipos, var->text, tipo))
                {
                    var_value->Gencode(tipos);
                }else
                {
                    std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo "+tipo ;
                    throw std::runtime_error(msgcompleto.c_str());\
                }

                break;
            }
        }   

        if (!encontrado) {
            std::string msgcompleto = "Error: La Variable " + var->text + " no esta declarada " ;
            throw std::runtime_error(msgcompleto.c_str());\
        }

    }else if(var_value->isA(CaracterExpr_kind))
    {
        if(siTipo(tipos, var->text, "Caracter"))
        {
            var_value->Gencode(tipos);
        }else
        {
            std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo Caracter" ;
            throw std::runtime_error(msgcompleto.c_str());\
        }
    }else if(var_value->isA(BoolExpr_kind))
    {
        if(siTipo(tipos, var->text, "Booleano"))
        {
            var_value->Gencode(tipos);

        }else
        {
            std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo Booleano" ;
            throw std::runtime_error(msgcompleto.c_str());\
        }
    }else
    {
        var_value->Gencode(tipos);
    }
    
    

    place = var->place;
    code += var_value->code;
    code += "\tmov eax, " + getPlace(var_value) + "\n";
    code += "\tmov " + getPlace(var) + ", eax\n"; 
    return "";
}

Gencode(EscribaStmt) {
    bool encontrado = false;


    
    if(expr1->isA(NumExpr_kind))
    {
        expr1->Gencode(tipos);
        code += expr1->code;
        code += "\tmov eax, 1\n";
        code += "\tmov ebx, " + getPlace(expr1) + "\n"; 

    }else if (expr1->isA(IdentExpr_kind))
    {
        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);

        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                

                expr1->Gencode(tipos);



                break;
            }
        }   

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());
        }
        code += expr1->code;
        if(tipo == "Entero")
        {
            code += "\tmov eax, 1\n";
            code += "\tmov ebx, " + getPlace(expr1) + "\n"; 
            
        }else if(tipo == "Caracter")
        {
            code += "\tmov eax, 11\n";
            code += "\tmov ebx, " + getPlace(expr1) + "\n"; 

        }else if(tipo == "Booleano")
        {
            code += "\tmov esi, 0x10000000\n";
            code += "\tlea ebx, [esi+4]\n";
            std::string label1 = newLabel();
            std::string label2 = newLabel();
            code += "\tmov eax, "+ getPlace(expr1) +"\n";
            code += "\tcmp eax, 0\n";
            code += "\tje "+ label1 +"\n";
            
            code += "\tmov dword [ebx], 0x64726576\n"; 
            code += "\tmov dword [ebx + 4], 0x72656461\n";
            code += "\tmov dword  [ebx + 8], 0x6f\n"; 
            code += "\tmov dword  [ebx + 9], 0\n";
            code += "\tjmp "+ label2 +"\n";
            
            code += label1 + ":\n"; 
            code += "\tmov dword [ebx], 0x736c6166\n"; 
            code += "\tmov dword [ebx + 4], 0x6f\n";
            code += "\tmov dword  [ebx + 5], 0\n"; 
            
            code += label2 + ":\n";
            code += "\tmov eax, 4\n";
            code += "\tlea ebx, [esi+4]\n";
            
        }
       

    }else if(expr1->isA(CaracterExpr_kind))
    {
        expr1->Gencode(tipos);
        code += expr1->code;
        code += "\tmov eax, 11\n";
        code += "\tmov ebx, " + getPlace(expr1) + "\n"; 
    
    }else if (expr1->isA(BoolExpr_kind))
    {
        expr1->Gencode(tipos);
        code += "\tmov esi, 0x10000000\n";
        code += "\tlea ebx, [esi+4]\n";
        
        
        if(expr1->place == "1"){
            code += "\tmov dword [ebx], 0x64726576\n"; 
            code += "\tmov dword [ebx + 4], 0x72656461\n";
            code += "\tmov dword  [ebx + 8], 0x6f\n"; 
            code += "\tmov dword  [ebx + 9], 0\n";
        }
        else
        {
            code += "\tmov dword [ebx], 0x736c6166\n"; 
            code += "\tmov dword [ebx + 4], 0x6f\n";
            code += "\tmov dword  [ebx + 5], 0\n"; 
        }
        
        code += "\tmov eax, 4\n";
        code += "\tlea ebx, [esi+4]\n";

    
    }else if(expr1->isA(CadenaExpr_kind))
    {
        expr1->Gencode(tipos);
        
        code += "\tmov esi, 0x10000000\n";
        code += "\tlea ebx, [esi+4]\n";
        int i = 0;
        
        std::stringstream ss;
        for (i = 0; static_cast<CadenaExpr *>(expr1)->cadena[i] != '\0'; ++i) {

            if (i % 4 == 0) {
                code += "\n\tmov [ebx + "+std::to_string(i)+"], 0x";
                std::cout<<"i=" << i<< "\n";
            }
            
            //code += std::ios_base& << std::_Setw(2) << std::setfill('0') << static_cast<int>(static_cast<CadenaExpr *>(expr1)->cadena[i]);
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(static_cast<CadenaExpr *>(expr1)->cadena[i]);
            
           if(i >= 0 && (i-3) % 4 == 0 || i == static_cast<CadenaExpr *>(expr1)->cadena.size() - 1)
            {
                
                std::vector<std::string> pares;

                // Dividir la cadena en pares de dos caracteres
                for (size_t i = 0; i < ss.str().length(); i += 2) {
                    pares.push_back(ss.str().substr(i, 2));
                }

                // Invertir el vector de pares
                std::reverse(pares.begin(), pares.end());

                // Construir la cadena resultante
                std::ostringstream resultado;
                for (const auto& par : pares) {
                    resultado << par;
                }

                code += resultado.str();
                ss.str("");
            }

        }

        code += "\n\tmov [ebx +"+std::to_string(i)+"], 0\n";
        code += "\tmov eax, 4\n";
        code += "\tlea ebx, [esi+4]\n";
    }
    else
    {
        expr1->Gencode(tipos);
        code += expr1->code;
        code += "\tmov eax, 1\n";
        code += "\tmov ebx, " + getPlace(expr1) + "\n"; 
    }
    

    
   
    code += "\tint 0x80\n";

    code += "\tmov eax, 11\n";
    code += "\tmov ebx, 10\n"; 
    code += "\tint 0x80\n";
    return code;
}


Gencode(BlockStmts) {
    stmt1->Gencode(tipos);
    stmt2->Gencode(tipos);

    code = stmt1->code + stmt2->code;

    return code;
}

Gencode(DeclaracionStmt) {
    ident1->Gencode(tipos);
    ident2->Gencode(tipos);
    
    code = ident1->code + ident2->code;

    return code;
}

Gencode(Declaracionvariable) {
    ident->Gencode(tipos);
    ident2->Gencode(tipos);

    code = ident->code + ident2->code;


    return code;
}


Gencode(ForStmt) {
    std::string label1 = newLabel(); // label de for
    
    std::string label2 = newLabel(); // finalizacion del for
    std::string label3 = newLabel(); // label que no entro al for
   

    asignacion->Gencode(tipos);
    hasta->Gencode(tipos);
    stmtst->Gencode(tipos);

    
    code += asignacion->code;
    code += label1 + ":\n";
    code += "\tmov eax, " + getPlace(asignacion) + "\n";
    code += "\tcmp eax, "+getPlace(hasta)+"\n";
    code += "\tjg " + label3 + "\n";
    code += stmtst->code;
    code += "\tadd " + getPlace(asignacion) + ", 1\n";
    code += "\tjmp " + label1 + "\n";
    code += label3 + ":\n";
    return code;
}


Gencode(WhileStmt) {
    std::string label1 = newLabel(); // label de for
    std::string label2 = newLabel(); // finalizacion del for
    std::string label3 = newLabel(); // label que no entro al for
   

    condi->Gencode(tipos);
    stmt_tr->Gencode(tipos);

    code += label1 + ":\n";
    code += condi->code;
    code += "\tmov eax, " + getPlace(condi) + "\n";
    code += "\tcmp eax, 0\n";
    code += "\tje " + label3 + "\n";
    code += stmt_tr->code;
    code += "\tjmp " + label1 + "\n";
    code += label3 + ":\n";
    return code;
}


Gencode(IfStmt) {
    std::string label1 = newLabel(); // label de for
    std::string label2 = newLabel(); // finalizacion del for
    std::string label3 = newLabel(); // label que no entro al for
    std::string label4 = newLabel();

    condi->Gencode(tipos);
    stmt_tr->Gencode(tipos);
    stmt_f->Gencode(tipos);
    code += label1 + ":\n";
    code += condi->code;
    code += "\tmov eax, " + getPlace(condi) + "\n";
    code += "\tcmp eax, 0\n";
    code += "\tje " + label3 + "\n";
    code += stmt_tr->code;
    code += "\tjmp "+ label4 +"\n";
    code += label3 + ":\n";
    code += stmt_f->code;
    code += label4 + ":\n";
    return code;
}

Gencode(RetorneStmt) {

    retorno->Gencode(tipos);
    code += retorno->code;
    code += "\tmov ecx, " + getPlace(retorno) + "\n";

    return code;
}


Gencode(Vacio) {
    place = "";
    code = "";
    return "";
}


Gencode(LeaStmt) {
    leer->Gencode(tipos);

    code += "\tmov eax, 5\n";
    code += "\tint 0x80\n";
    code += "\tmov "+getPlace(leer)+", eax\n";

    return "";
}

Gencode(Program) {
    //stmts->Gencode(tipos);
    declVar->Gencode(tipos);
    declFun->Gencode(tipos);
    main->Gencode(tipos);
    //code = varia;
    for (const auto& var : vars) {
        std::cout<< var.Identificador << " = " << var.direccion <<"\n";
        code += "\tpush 0\n";
    }

    code += "\tcall main\n";
    code += "\tadd esp, " + std::to_string(getOffset() - 4) + "\n";
    code += "\t#stop\n";
    code += "main:\n";
    code += "\tpush ebp\n";
    code += "\tmov ebp, esp\n";
    code += "\tsub esp, " + std::to_string(getOffset_stmt()) + "\n";
    code += main->code;
    code += "\tleave\n\tret\n";

    
    return code;
}





