

%decls %{
    #include <string>
    #include <unordered_map>
    #include <iostream>
    #include <iomanip>
    #include <vector>
    #include <variant>

    using valores = std::variant<std::string, int>;
    using stdstring = std::string;

    struct variable_valor{
        stdstring Identificador;
        stdstring direccion;
        valores valor;
    };

    struct variable_Tipo{
        stdstring Tipo;
        stdstring variable;
    };

    using Variables = std::vector<variable_valor>;
    using Tipos = std::vector<variable_Tipo>;

    void resetCodegen();
	int getOffset();
	int addOffset();
	stdstring newLabel();
    bool siTipo(Tipos& tipo_var, std::string var, std::string tipo);
    stdstring TipoVar(std::string var);
%}

%{
    #include <iostream>
    #include <string>
    #include <variant>
    #include <iomanip>
    #include <vector>
    #include <algorithm>
    #include "CompiAst.hpp"
    int labels = 0;
    int offset = 4;
    int offset_stmts = 0;
    int drec = 0;
    Variables vars;

    
    void resetCodegen(){
		offset = 0;
		labels = 0;
		drec = 0;
	}

	int getOffset(){
		
		return offset;
	}

	int addOffset()
	{
		return offset += 4;
	}
    int getOffset_stmt(){
		
		return offset_stmts;
	}

	int addOffset_stmt()
	{
		return offset_stmts += 4;
	}

	stdstring newLabel()
	{
		std::string temp = "label_" + std::to_string(labels);
		labels += 1;
		return temp;
	}

	stdstring newTemp()
	{	
		std::string temp = "T" + std::to_string(drec);
		drec += 1;
		return temp;
	}

    stdstring getPlace(AstNode* e){
		if(e->isA(NumExpr_kind))
			return e->place;
        else if(e->isA(CaracterExpr_kind))
            return e->place;
        else if(e->isA(BoolExpr_kind))
            return e->place;
		return "dword ["+e->place+"]";
	}


    bool siTipo(Tipos& tipo_var, std::string var, std::string tipo)
    {
        for (int i =0 ; i < tipo_var.size(); i++)
        {
            if(tipo_var[i].variable == var)
            {
                if(tipo_var[i].Tipo == tipo)
                {
                    return true;
                }
            }
        }
        return false;
    }


    stdstring TipoVar(Tipos& tipo_var, std::string var)
    {
        for (int i =0 ; i < tipo_var.size(); i++)
        {
            if(tipo_var[i].variable == var)
            {
                return tipo_var[i].Tipo;
            }
        }

        return "";
    }
%}

%option lang = "C++"

%node AstNode %abstract %typedef = {
    %nocreate stdstring place;
    %nocreate stdstring code;
}

%node Expr AstNode %abstract


%node Program AstNode = {
    AstNode *declVar;
    AstNode *declFun;
    AstNode *main;
}

%node BinaryExpr Expr %abstract = {
    Expr *expr1;
    Expr *expr2;
}

%node AddExpr BinaryExpr
%node MulExpr BinaryExpr
%node DivExpr BinaryExpr
%node SubExpr BinaryExpr
%node ModExpr BinaryExpr

%node MayorExpr BinaryExpr
%node MenorExpr BinaryExpr
%node MayorIExpr BinaryExpr
%node MenorIExpr BinaryExpr
%node IgualExpr BinaryExpr
%node DesigualExpr BinaryExpr

%node OrExpr BinaryExpr
%node AndExpr BinaryExpr



%node NumExpr Expr = {
    int value;
}

%node IdentExpr Expr = {
    stdstring text;
}

%node BoolExpr Expr = {
    int booleano;
}

%node CaracterExpr Expr = {
    char character;
}
%node CadenaExpr Expr = {
    stdstring cadena;
}

%node ArregloExpr Expr = {
    stdstring txt;
}

%node Stmt AstNode %abstract 

%node Vacio Stmt = {

}

%node BlockStmts Stmt = {
    AstNode * stmt1;
    AstNode * stmt2; 
}
//nodo para declaraciones de variables

%node DeclaracionStmt Expr = {
    AstNode* ident1;
    AstNode* ident2;
}

%node Declaracionvariable Stmt = {
    AstNode * ident;
    AstNode * ident2;
}


%node AsignarStmt Stmt = {
    IdentExpr *var;
    AstNode *var_value;
}

%node ForStmt Stmt = {
    AsignarStmt * asignacion;
    Expr * hasta;
    AstNode * stmtst;
}


%node RepitaStmt Stmt = {
    AstNode * stmtst;
    Expr * condi;
    
}

%node EscribaStmt Stmt = {
    AstNode *expr1;
}

%node IfStmt Stmt = {
    AstNode *condi;
    AstNode *stmt_tr;
    AstNode *stmt_f;
}

%node WhileStmt Stmt = {
    AstNode *condi;
    AstNode *stmt_tr;
}

%node RetorneStmt Stmt = {
    AstNode *retorno;
}

%node LeaStmt Stmt = {
    AstNode *leer;
}


%operation %virtual stdstring Gencode(AstNode *this,Tipos& tipos)


Gencode(AddExpr) {
    place = "ebp - " + std::to_string(addOffset_stmt());

    expr1->Gencode(tipos);
    expr2->Gencode(tipos);

    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
        code += expr1->code + expr2->code;
        code += "\tmov eax, " + getPlace(expr1) + "\n";
        code += "\tadd eax, " + getPlace(expr2) + "\n";
        code += "\tmov [" + place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) + "\n";
            code += "\tadd eax, " + getPlace(expr2) + "\n";
            code += "\tmov [" + place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);

        if(tipo == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) + "\n";
            code += "\tadd eax, " + getPlace(expr2) + "\n";
            code += "\tmov [" + place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) + "\n";
            code += "\tadd eax, " + getPlace(expr2) + "\n";
            code += "\tmov [" + place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
    
    return code;
}

Gencode(MulExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    

    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
        code += expr1->code + expr2->code;
        code += "\tmov eax, " + getPlace(expr1) +"\n";
        code += "\timul eax, " + getPlace(expr2) + "\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) +"\n";
            code += "\timul eax, " + getPlace(expr2) + "\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);

        if(tipo == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) +"\n";
            code += "\timul eax, " + getPlace(expr2) + "\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) +"\n";
            code += "\timul eax, " + getPlace(expr2) + "\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
	return code;
}

Gencode(SubExpr) {
    place = "ebp - " + std::to_string(addOffset_stmt());

    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    
    
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
        code += expr1->code + expr2->code;
        code += "\tmov eax, " + getPlace(expr1) + "\n";
        code += "\tsub eax, " + getPlace(expr2) + "\n";
        code += "\tmov [" + place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) + "\n";
            code += "\tsub eax, " + getPlace(expr2) + "\n";
            code += "\tmov [" + place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);

        if(tipo == "Entero")
        {
           code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) + "\n";
            code += "\tsub eax, " + getPlace(expr2) + "\n";
            code += "\tmov [" + place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += expr1->code + expr2->code;
            code += "\tmov eax, " + getPlace(expr1) + "\n";
            code += "\tsub eax, " + getPlace(expr2) + "\n";
            code += "\tmov [" + place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
    return code;
}

Gencode(DivExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	code += "\tmov eax, " + getPlace(expr2) +"\n";
    code += "\tcdq\n";
    code += "\tmov ebx, "+ getPlace(expr1) +"\n";
    code += "\tidiv ebx\n";

	code += "\tmov ["+ place + "], eax\n";
	return code;
}

Gencode(MayorExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    std::string Etiqueta_mayor = newLabel();
	std::string Etiqueta_Fin = newLabel();
	
    
    
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
        code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
        code += "\tjle "+ Etiqueta_mayor +"\n";
        code += "\tmov eax, 1\n";
        code += "\tjmp "+Etiqueta_Fin+"\n";
        code += Etiqueta_mayor + ": \n";
        code += "\t mov eax, 0\n";
        code += Etiqueta_Fin + ":\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjle "+ Etiqueta_mayor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_mayor + ": \n";
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin + ":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        
        if(tipo == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjle "+ Etiqueta_mayor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_mayor + ": \n";
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin + ":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjle "+ Etiqueta_mayor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_mayor + ": \n";
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin + ":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }

	return code;
}

Gencode(MenorExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    std::string Etiqueta_menor = newLabel();
	std::string Etiqueta_Fin = newLabel();

    
    
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
        code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
        code += "\tjge "+ Etiqueta_menor +"\n";
        code += "\tmov eax, 1\n";
        code += "\tjmp "+Etiqueta_Fin+"\n";
        code += Etiqueta_menor + ": \n";
        code += "\t mov eax, 0\n";
        code += Etiqueta_Fin+":\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjge "+ Etiqueta_menor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_menor + ": \n";
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        //std::cout<< tipo;
        if(tipo == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjge "+ Etiqueta_menor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_menor + ": \n";
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjge "+ Etiqueta_menor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_menor + ": \n";
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }

	return code;
}

Gencode(MayorIExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    std::string Etiqueta_mayor = newLabel();
	std::string Etiqueta_Fin = newLabel();
    
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
        code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
        code += "\tjl " + Etiqueta_mayor +"\n";
        code += "\tmov eax, 1\n";
        code += "\tjmp " + Etiqueta_Fin + "\n";
        code += Etiqueta_mayor + ": \n";
        code += "\t mov eax, 0\n" ;
        code += Etiqueta_Fin + ":\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjl " + Etiqueta_mayor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp " + Etiqueta_Fin + "\n";
            code += Etiqueta_mayor + ": \n";
            code += "\t mov eax, 0\n" ;
            code += Etiqueta_Fin + ":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::cout<< tipo;
        if(tipo == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjl " + Etiqueta_mayor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp " + Etiqueta_Fin + "\n";
            code += Etiqueta_mayor + ": \n";
            code += "\t mov eax, 0\n" ;
            code += Etiqueta_Fin + ":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjl " + Etiqueta_mayor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp " + Etiqueta_Fin + "\n";
            code += Etiqueta_mayor + ": \n";
            code += "\t mov eax, 0\n" ;
            code += Etiqueta_Fin + ":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
	return code;
}

Gencode(MenorIExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    std::string Etiqueta_menor = newLabel();
	std::string Etiqueta_Fin = newLabel();
	

    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
       code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
        code += "\tjg "+ Etiqueta_menor +"\n";
        code += "\tmov eax, 1\n";
        code += "\tjmp "+Etiqueta_Fin+"\n";
        code += Etiqueta_menor+": \n";
        code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjg "+ Etiqueta_menor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_menor+": \n";
            code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::cout<< tipo;
        if(tipo == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjg "+ Etiqueta_menor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_menor+": \n";
            code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjg "+ Etiqueta_menor +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_menor+": \n";
            code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
	return code;
}

Gencode(IgualExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    std::string Etiqueta_igual = newLabel();
	std::string Etiqueta_Fin = newLabel();
	
    std::cout<< expr1->getKind();
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
       code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
        code += "\tjne "+ Etiqueta_igual +"\n";
        code += "\tmov eax, 1\n";
        code += "\tjmp "+Etiqueta_Fin+"\n"; 
        code += Etiqueta_igual+": \n";
        code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = ",Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = ";Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
          code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjne "+ Etiqueta_igual +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n"; 
            code += Etiqueta_igual+": \n";
            code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "lError: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "kError:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        //std::cout<< tipo;
        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjne "+ Etiqueta_igual +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n"; 
            code += Etiqueta_igual+": \n";
            code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
            code +=  "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "aError: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "hError:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tjne "+ Etiqueta_igual +"\n";
            code += "\tmov eax, 1\n";
            code += "\tjmp "+Etiqueta_Fin+"\n"; 
            code += Etiqueta_igual+": \n";
            code += "\t mov eax, 0\n"+Etiqueta_Fin+":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "dError: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "bError: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
	return code;
}

Gencode(DesigualExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    std::string Etiqueta_desigual = newLabel();
	std::string Etiqueta_Fin = newLabel();
	
    
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
      code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
        code += "\tje "+ Etiqueta_desigual +"\n";
        code += "\tmov eax, 1\n"; 
        code += "\tjmp "+Etiqueta_Fin+"\n";
        code += Etiqueta_desigual + ": \n"; 
        code += "\t mov eax, 0\n";
        code += Etiqueta_Fin +":\n";
        code += "\tmov ["+ place + "], eax\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
          code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tje "+ Etiqueta_desigual +"\n";
            code += "\tmov eax, 1\n"; 
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_desigual + ": \n"; 
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin +":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::cout<< tipo;
        if(tipo == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tje "+ Etiqueta_desigual +"\n";
            code += "\tmov eax, 1\n"; 
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_desigual + ": \n"; 
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin +":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
         code += "\tmov eax, " + getPlace(expr1) +"\n\tcmp eax, " + getPlace(expr2) + "\n";
            code += "\tje "+ Etiqueta_desigual +"\n";
            code += "\tmov eax, 1\n"; 
            code += "\tjmp "+Etiqueta_Fin+"\n";
            code += Etiqueta_desigual + ": \n"; 
            code += "\t mov eax, 0\n";
            code += Etiqueta_Fin +":\n";
            code += "\tmov ["+ place + "], eax\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
	return code;
}

Gencode(ModExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
	
	expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

	

    
    if(expr1->isA(NumExpr_kind) && expr2->isA(NumExpr_kind))
    {
      code += "\tmov eax, " + getPlace(expr1) +"\n";
        code += "\tcdq\n";
        code += "\tmov ebx, "+ getPlace(expr2) +"\n";
        code += "\tidiv ebx\n";

        code += "\tmov ["+ place + "], edx\n";
        code += "\tmov eax, edx\n";
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo1 = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::string tipo2 = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo1 == "Entero" && tipo2 == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n";
            code += "\tcdq\n";
            code += "\tmov ebx, "+ getPlace(expr2) +"\n";
            code += "\tidiv ebx\n";

            code += "\tmov ["+ place + "], edx\n";
            code += "\tmov eax, edx\n";
        }else
        {
            std::string msgcompleto = "Error: tipos de datos icorrectos " + static_cast<IdentExpr *>(expr1)->text + " " + static_cast<IdentExpr *>(expr2)->text;;
            throw std::runtime_error(msgcompleto.c_str());\
        }
        
    }else if (expr1->isA(IdentExpr_kind) && expr2->isA(NumExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);
        std::cout<< tipo;
        if(tipo == "Entero")
        {
           code += "\tmov eax, " + getPlace(expr1) +"\n";
            code += "\tcdq\n";
            code += "\tmov ebx, "+ getPlace(expr2) +"\n";
            code += "\tidiv ebx\n";

            code += "\tmov ["+ place + "], edx\n";
            code += "\tmov eax, edx\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else if (expr1->isA(NumExpr_kind) && expr2->isA(IdentExpr_kind))
    {
        bool encontrado = false;
        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr2)->text) {
                encontrado = true;
                break;
            }
        }

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }

        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr2)->text);

        if(tipo == "Entero")
        {
            code += "\tmov eax, " + getPlace(expr1) +"\n";
            code += "\tcdq\n";
            code += "\tmov ebx, "+ getPlace(expr2) +"\n";
            code += "\tidiv ebx\n";

            code += "\tmov ["+ place + "], edx\n";
            code += "\tmov eax, edx\n";
        }else
        {
            std::string msgcompleto = "Error: Tipo de datos incorrecto " + static_cast<IdentExpr *>(expr2)->text;
            throw std::runtime_error(msgcompleto.c_str());\
        }
       
    }else
    {
        std::string msgcompleto = "Error: Tipos ded datos incorrectos " ;
        throw std::runtime_error(msgcompleto.c_str());
    }
	return code;
}

Gencode(OrExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
    
    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;

    code += "\tmov eax, " + getPlace(expr1) +"\n";
    code += "\tor eax, " + getPlace(expr2) + "\n";
    code += "\tmov ["+ place + "], eax\n";
    
    return code;
}

Gencode(AndExpr) {
    place = "ebp - "+std::to_string(addOffset_stmt());
    
    expr1->Gencode(tipos);
    expr2->Gencode(tipos);
    code += expr1->code + expr2->code;
    code += "\tmov eax, " + getPlace(expr1) +"\n";
    code += "\tand eax, " + getPlace(expr2) + "\n";
    code += "\tmov ["+ place + "], eax\n";
    
    
    return code;
}

Gencode(NumExpr) {
    place = std::to_string(value);
    code = "";
    return "";
}

Gencode(BoolExpr) {
    place = std::to_string(booleano);
    code = "";
    return "";
}

Gencode(IdentExpr) {
    bool encontrado = false;
    for (const auto& var : vars) {
        if (var.Identificador == text) {
            encontrado = true;
            place = var.direccion;
            break;
        }
    }

    if (!encontrado) {
        place = "ebp + " +std::to_string(addOffset());
        vars.push_back({text, place, 0});
    }
    return "";
}

Gencode(CaracterExpr) {

    int valor_ascii = static_cast<int>(character);
    place = std::to_string(valor_ascii);
    code = "";
    return "";
}

Gencode(CadenaExpr) {
    place = "";
    code = "";
    return "";
}

Gencode(ArregloExpr) {
    code = "";
    place ="";
    return "";
}



Gencode(AsignarStmt) {

    bool encontrado = false;
    for (const auto& vari : vars) {
        if (vari.Identificador == var->text) {
            encontrado = true;
            
            var->Gencode(tipos);

            break;
        }
    }

    if (!encontrado) {
        
        std::string msgcompleto = "Error:variable no declarada " + var->text;
        throw std::runtime_error(msgcompleto.c_str());\
    }
    
    
    if(var_value->isA(NumExpr_kind))
    {
        
        if(siTipo(tipos, var->text, "Entero"))
        {
            var_value->Gencode(tipos);
        }else
        {
            std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo Entero" ;
            throw std::runtime_error(msgcompleto.c_str());\
        }

    }else if (var_value->isA(IdentExpr_kind))
    {

        for (const auto& vari : vars) {
            if (vari.Identificador == var->text) {
                encontrado = true;
                std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(var_value)->text);
                
                if(siTipo(tipos, var->text, tipo))
                {
                    var_value->Gencode(tipos);
                }else
                {
                    std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo " + tipo ;
                    throw std::runtime_error(msgcompleto.c_str());\
                }

                break;
            }
        }   

        if (!encontrado) {
            std::string msgcompleto = "Error: La Variable " + var->text + " no esta declarada " ;
            throw std::runtime_error(msgcompleto.c_str());\
        }

    }else if(var_value->isA(CaracterExpr_kind))
    {
        if(siTipo(tipos, var->text, "Caracter"))
        {
            var_value->Gencode(tipos);
        }else
        {
            std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo Caracter" ;
            throw std::runtime_error(msgcompleto.c_str());\
        }

    }else if(var_value->isA(BoolExpr_kind))
    {
        if(siTipo(tipos, var->text, "Booleano"))
        {
            var_value->Gencode(tipos);

        }else
        {
            std::string msgcompleto = "Error: La Variable " + var->text + " no es de tipo Booleano" ;
            throw std::runtime_error(msgcompleto.c_str());\
        }

    }else
    {
        var_value->Gencode(tipos);
    }
    
    

    place = var->place;
    code += var_value->code;
    code += "\tmov eax, " + getPlace(var_value) + "\n";
    code += "\tmov " + getPlace(var) + ", eax\n"; 
    return "";
}

Gencode(EscribaStmt) {
    bool encontrado = false;

    if(expr1->isA(NumExpr_kind))
    {
        expr1->Gencode(tipos);
        code += expr1->code;
        code += "\tmov eax, 1\n";
        code += "\tmov ebx, " + getPlace(expr1) + "\n"; 

    }else if (expr1->isA(IdentExpr_kind))
    {
        std::string tipo = TipoVar(tipos, static_cast<IdentExpr *>(expr1)->text);

        for (const auto& vari : vars) {
            if (vari.Identificador == static_cast<IdentExpr *>(expr1)->text) {
                encontrado = true;

                expr1->Gencode(tipos);

                break;
            }
        }   

        if (!encontrado) {
            std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(expr1)->text;
            throw std::runtime_error(msgcompleto.c_str());
        }
        code += expr1->code;
        if(tipo == "Entero")
        {
            code += "\tmov eax, 1\n";
            code += "\tmov ebx, " + getPlace(expr1) + "\n"; 
            
        }else if(tipo == "Caracter")
        {
            code += "\tmov eax, 11\n";
            code += "\tmov ebx, " + getPlace(expr1) + "\n"; 

        }else if(tipo == "Booleano")
        {
            code += "\tmov esi, 0x10000000\n";
            code += "\tlea ebx, [esi+4]\n";
            std::string label1 = newLabel();
            std::string label2 = newLabel();
            code += "\tmov eax, "+ getPlace(expr1) +"\n";
            code += "\tcmp eax, 0\n";
            code += "\tje "+ label1 +"\n";
            
            code += "\tmov dword [ebx], 0x64726576\n"; 
            code += "\tmov dword [ebx + 4], 0x72656461\n";
            code += "\tmov dword  [ebx + 8], 0x6f\n"; 
            code += "\tmov dword  [ebx + 9], 0\n";
            code += "\tjmp "+ label2 +"\n";
            
            code += label1 + ":\n"; 
            code += "\tmov dword [ebx], 0x736c6166\n"; 
            code += "\tmov dword [ebx + 4], 0x6f\n";
            code += "\tmov dword  [ebx + 5], 0\n"; 
            
            code += label2 + ":\n";
            code += "\tmov eax, 4\n";
            code += "\tlea ebx, [esi+4]\n";
            
        }
       

    }else if(expr1->isA(CaracterExpr_kind))
    {
        expr1->Gencode(tipos);
        code += expr1->code;
        code += "\tmov eax, 11\n";
        code += "\tmov ebx, " + getPlace(expr1) + "\n"; 
    
    }else if (expr1->isA(BoolExpr_kind))
    {
        expr1->Gencode(tipos);
        code += "\tmov esi, 0x10000000\n";
        code += "\tlea ebx, [esi+4]\n";
        
        
        if(expr1->place == "1"){
            code += "\tmov dword [ebx], 0x64726576\n"; 
            code += "\tmov dword [ebx + 4], 0x72656461\n";
            code += "\tmov dword  [ebx + 8], 0x6f\n"; 
            code += "\tmov dword  [ebx + 9], 0\n";
        }
        else
        {
            code += "\tmov dword [ebx], 0x736c6166\n"; 
            code += "\tmov dword [ebx + 4], 0x6f\n";
            code += "\tmov dword  [ebx + 5], 0\n"; 
        }
        
        code += "\tmov eax, 4\n";
        code += "\tlea ebx, [esi+4]\n";

    
    }else if(expr1->isA(CadenaExpr_kind))
    {
        expr1->Gencode(tipos);
        
        code += "\tmov esi, 0x10000000\n";
        code += "\tlea ebx, [esi+4]\n";
        int i = 0;
        
        std::stringstream ss;
        for (i = 0; static_cast<CadenaExpr *>(expr1)->cadena[i] != '\0'; ++i) {

            if (i % 4 == 0) {
                code += "\n\tmov [ebx + " + std::to_string(i) + "], 0x";   
            }
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(static_cast<CadenaExpr *>(expr1)->cadena[i]);
            
           if(i >= 0 && (i-3) % 4 == 0 || i == static_cast<CadenaExpr *>(expr1)->cadena.size() - 1)
            {
                
                std::vector<std::string> pares;
                for (size_t i = 0; i < ss.str().length(); i += 2) {
                    pares.push_back(ss.str().substr(i, 2));
                }
                std::reverse(pares.begin(), pares.end());
                std::ostringstream resultado;
                for (const auto& par : pares) {
                    resultado << par;
                }

                code += resultado.str();
                ss.str("");
            }

        }

        code += "\n\tmov [ebx +"+std::to_string(i)+"], 0\n";
        code += "\tmov eax, 4\n";
        code += "\tlea ebx, [esi+4]\n";
    }
    else
    {
        expr1->Gencode(tipos);
        code += expr1->code;
        code += "\tmov eax, 1\n";
        code += "\tmov ebx, " + getPlace(expr1) + "\n"; 
    }
    

    
   
    code += "\tint 0x80\n";

    return code;
}


Gencode(BlockStmts) {
    stmt1->Gencode(tipos);
    stmt2->Gencode(tipos);

    code = stmt1->code + stmt2->code;

    return code;
}

Gencode(DeclaracionStmt) {
    ident1->Gencode(tipos);
    ident2->Gencode(tipos);
    
    code = ident1->code + ident2->code;

    return code;
}

Gencode(Declaracionvariable) {
    ident->Gencode(tipos);
    ident2->Gencode(tipos);

    code = ident->code + ident2->code;


    return code;
}

Gencode(RepitaStmt){
    std::string Etiqueta_repita = newLabel(); 
    stmtst->Gencode(tipos);
    condi->Gencode(tipos);


    code += Etiqueta_repita + ":\n";
    code += stmtst->code;
    code += condi->code;
    code += "\tmov eax, " + getPlace(condi) + "\n";
    code += "\tcmp eax, 0\n";
    code += "\tjne " + Etiqueta_repita + "\n";


    return code;
}

Gencode(ForStmt) {
    std::string label1 = newLabel(); 
    
    std::string label2 = newLabel(); 
    std::string label3 = newLabel(); 
   

    asignacion->Gencode(tipos);
    hasta->Gencode(tipos);
    stmtst->Gencode(tipos);

    
    code += asignacion->code;
    code += label1 + ":\n";
    code += "\tmov eax, " + getPlace(asignacion) + "\n";
    code += "\tcmp eax, "+getPlace(hasta)+"\n";
    code += "\tjg " + label3 + "\n";
    code += stmtst->code;
    code += "\tadd " + getPlace(asignacion) + ", 1\n";
    code += "\tjmp " + label1 + "\n";
    code += label3 + ":\n";
    return code;
}


Gencode(WhileStmt) {
    std::string label1 = newLabel(); // label de for
    std::string label2 = newLabel(); // finalizacion del for
    std::string label3 = newLabel(); // label que no entro al for
   

    condi->Gencode(tipos);
    stmt_tr->Gencode(tipos);

    code += label1 + ":\n";
    code += condi->code;
    code += "\tmov eax, " + getPlace(condi) + "\n";
    code += "\tcmp eax, 0\n";
    code += "\tje " + label3 + "\n";
    code += stmt_tr->code;
    code += "\tjmp " + label1 + "\n";
    code += label3 + ":\n";
    return code;
}


Gencode(IfStmt) {
    std::string label1 = newLabel(); // label de for
    std::string label2 = newLabel(); // finalizacion del for
    std::string label3 = newLabel(); // label que no entro al for
    std::string label4 = newLabel();

    condi->Gencode(tipos);
    stmt_tr->Gencode(tipos);
    stmt_f->Gencode(tipos);
    code += label1 + ":\n";
    code += condi->code;
    code += "\tmov eax, " + getPlace(condi) + "\n";
    code += "\tcmp eax, 0\n";
    code += "\tje " + label3 + "\n";
    code += stmt_tr->code;
    code += "\tjmp "+ label4 +"\n";
    code += label3 + ":\n";
    code += stmt_f->code;
    code += label4 + ":\n";
    return code;
}

Gencode(RetorneStmt) {

    retorno->Gencode(tipos);
    code += retorno->code;
    code += "\tmov ecx, " + getPlace(retorno) + "\n";

    return code;
}


Gencode(Vacio) {
    place = "";
    code = "";
    return "";
}


Gencode(LeaStmt) {
    
    bool encontrado = false;
    for (const auto& vari : vars) {
        if (vari.Identificador == static_cast<IdentExpr *>(leer)->text) {
            encontrado = true;
            
           leer->Gencode(tipos);

            break;
        }
    }

    if (!encontrado) {
        
        std::string msgcompleto = "Error:variable no declarada " + static_cast<IdentExpr *>(leer)->text;
        throw std::runtime_error(msgcompleto.c_str());\
    }

    code += "\tmov eax, 5\n";
    code += "\tint 0x80\n";
    code += "\tmov "+getPlace(leer)+", eax\n";

    return "";
}

Gencode(Program) {
    declVar->Gencode(tipos);
    declFun->Gencode(tipos);
    main->Gencode(tipos);
    for (const auto& var : vars) {
       
        code += "\tpush 0\n";
    }

    code += "\tcall main\n";
    code += "\tadd esp, " + std::to_string(getOffset() - 4) + "\n";
    code += "\t#stop\n";
    code += "main:\n";
    code += "\tpush ebp\n";
    code += "\tmov ebp, esp\n";
    code += "\tsub esp, " + std::to_string(getOffset_stmt()) + "\n";
    code += main->code;
    code += "\tleave\n\tret\n";

    
    return code;
}





